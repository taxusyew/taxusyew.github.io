<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: Android | Taxus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="进入前端的后端">
<meta property="og:type" content="website">
<meta property="og:title" content="Taxus">
<meta property="og:url" content="http://yoursite.com/tags/Android/index.html">
<meta property="og:site_name" content="Taxus">
<meta property="og:description" content="进入前端的后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Taxus">
<meta name="twitter:description" content="进入前端的后端">
  
    <link rel="alternative" href="/atom.xml" title="Taxus" type="application/atom+xml">
  
  
    <link rel="icon" href="img/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Taxus</a></h1>
		</hgroup>

		
		<p class="header-subtitle">进入前端的后端</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/taxusyew" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/2014/" style="font-size: 10px;">2014</a> <a href="/tags/APICloud/" style="font-size: 12px;">APICloud</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/JS/" style="font-size: 18px;">JS</a> <a href="/tags/RSA/" style="font-size: 10px;">RSA</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/centos/" style="font-size: 10px;">centos</a> <a href="/tags/chromium/" style="font-size: 12px;">chromium</a> <a href="/tags/emacs/" style="font-size: 14px;">emacs</a> <a href="/tags/git/" style="font-size: 12px;">git</a> <a href="/tags/grunt/" style="font-size: 10px;">grunt</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/irc/" style="font-size: 10px;">irc</a> <a href="/tags/touch/" style="font-size: 10px;">touch</a> <a href="/tags/view/" style="font-size: 18px;">view</a> <a href="/tags/zsh/" style="font-size: 10px;">zsh</a> <a href="/tags/主题/" style="font-size: 10px;">主题</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/快捷键/" style="font-size: 10px;">快捷键</a> <a href="/tags/清单/" style="font-size: 10px;">清单</a> <a href="/tags/算法/" style="font-size: 16px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/配置/" style="font-size: 10px;">配置</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Timing is everything.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Taxus</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="img/author.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Taxus</h1>
			</hgroup>
			
			<p class="header-subtitle">进入前端的后端</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/taxusyew" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-20150427screendensities" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/27/20150427screendensities/" class="article-date">
  	<time datetime="2015-04-27T07:28:04.000Z" itemprop="datePublished">4月 27 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/27/20150427screendensities/">Different Densities 不同屏幕分辨率</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Supporting_Different_Densities_支持不同分辨率">Supporting Different Densities 支持不同分辨率</h1><p><a href="http://developer.android.com/training/multiscreen/screendensities.html" target="_blank" rel="external">原文地址</a><br>这节课向你展示如何通过提供不同的资源、使用与分辨率无关的单位来支持不同屏幕分辨率。</p>
<h2 id="Use_Density-independent_Pixels_使用密度无关像素">Use Density-independent Pixels 使用密度无关像素</h2><p>在设计布局时，你必须避免一个常见的陷阱就是使用绝对像素定义距离或大小。使用像素定义布局尺寸是个问题，因为不同屏幕有不同的像素密度，所以相同数量的像素可能在不同的设备上对应不同的物理尺寸。因此，当指明尺寸的时候，总是使用<code>dp</code>或<code>sp</code>单位。<code>dp</code>是一个密度无关的像素，它对应一个像素在160dpi下的物理尺寸，(注：<a href="http://www.zhihu.com/question/20697111" title="为什么基于160dpi" target="_blank" rel="external">为什么基于160dpi</a>)。<code>sp</code>是基于相同基数的单位，但是会根据用户首选的文本大小缩放(它是一个缩放独立(scale-independent)的像素)，所以在定义文本大小的时候必须使用这个尺寸单位(但是永远别用于布局尺寸)。</p>
<p>例如，当你设置两个view间的空白的时候，使用<code>dp</code>而非<code>px</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:text</span>=<span class="value">"@string/clickme"</span></span><br><span class="line">    <span class="attribute">android:layout_marginTop</span>=<span class="value">"20dp"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当指明文本大小的时候，总是使用<code>sp</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:textSize</span>=<span class="value">"20sp"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Provide_Alternative_Bitmaps_提供替换位图">Provide Alternative Bitmaps 提供替换位图</h2><p>因为Android会运行在屏幕尺寸差异很大的设备上，你必须总是根据每个通用密度提供特定的位图资源:low,medium,high,extra-high密度。这将帮助你在所有的屏幕密度上都获得很好的图像效果和性能。</p>
<p>为了生成这些图像，你应该从原始的矢量图开始，根据下面的比例为每个密度生成图像：</p>
<ul>
<li>xhdpi:2.0</li>
<li>hdpi: 1.5</li>
<li>mdpi:1.0 (基线)</li>
<li>ldpi: 0.75</li>
</ul>
<p>这意味着如果你为xhdpi设备生成一个200X200的图像，就必须为hdpi，mdpi,ldpi生成相应的150X150, 100X100, 75X75资源。</p>
<p>将这些图像放置在<code>res/</code>文件夹下适当的位置，然后系统在运行时会自动根据设备的屏幕密度挑选合适的文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyProject/</span><br><span class="line">  res/</span><br><span class="line">    drawable-xhdpi/</span><br><span class="line">        awesomeimage.png</span><br><span class="line">    drawable-hdpi/</span><br><span class="line">        awesomeimage.png</span><br><span class="line">    drawable-mdpi/</span><br><span class="line">        awesomeimage.png</span><br><span class="line">    drawable-ldpi/</span><br><span class="line">        awesomeimage.png</span><br></pre></td></tr></table></figure></p>
<p>任何时候你引用<code>@drawable/awesomeimage</code>，系统会根据屏幕dpi选择合适的图片。</p>
<p>把应用的启动图标放在<code>mipmap/</code>文件夹下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res/...</span><br><span class="line">    mipmap-ldpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br><span class="line">    mipmap-mdpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br><span class="line">    mipmap-hdpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br><span class="line">    mipmap-xhdpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br><span class="line">    mipmap-xxhdpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br><span class="line">    mipmap-xxxhdpi/...</span><br><span class="line">        finished_launcher_asset.png</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：应该把所有的启动图标都放在<code>res/mipmap-[density]/</code>文件夹下，而不是<code>drawable/</code>文件夹，来确保启动app使用最佳分辨率。有关mipmap文件夹的更多信息，请查看 <a href="http://developer.android.com/tools/projects/index.html#mipmap" target="_blank" rel="external">管理项目概览</a></p>
</blockquote>
<p>查看<a href="http://developer.android.com/design/style/iconography.html" title="Icon Design Guidelines" target="_blank" rel="external">图标设计指导</a>，获取创建应用图标的更多提示。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-20150422Graphics-architecture" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/22/20150422Graphics-architecture/" class="article-date">
  	<time datetime="2015-04-22T02:48:11.000Z" itemprop="datePublished">4月 22 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/22/20150422Graphics-architecture/">Graphics architecture 图形架构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Graphics_architecture_图形架构">Graphics architecture 图形架构</h1><p><a href="http://source.android.com/devices/graphics/architecture.html#activity" target="_blank" rel="external">原文地址</a></p>
<p><em>所有开发者都应该知道Surface、SurfaceHolder、EGLSurface, SurfaceView, GLSurfaceView, SurfaceTexture, TextureView, 和 SurfaceFlinger.</em></p>
<p>这篇文章描述了Android系统级图形架构的重要元素，和它是如何被应用框架、多媒体系统使用。关注点在于缓存中的图形数据如何在系统中移动。如果你好奇过SurfaceView和TextreView是如何运作的，或者Surface和EGLSurface是如何交互的，那么你就来对了地方。</p>
<p>假定你已经有了一些Android开发经验。不需要你有app框架的详细知识，而且会涉及到很少的API调用，但这里所列的材料并不与其他公共文档重复很多。这篇文章的目的是理解参与渲染输出的帧的重要事件，所以你在设计程序的时候做出明智的选择。为了这个目标，我们从底层讲述了UI类如何工作学起，而非只是如何使用它们。</p>
<p>之前的章节包含了后面章节所需的背景材料，所以最好通读全文而不是直接跳到感兴趣的章节。我们从解释Android图形缓存开始，描述组成、显示机制，然后过渡到为组件提供数据的高级机制(the higher-level mechanisms that supply the compositor with data)。</p>
<p>本文主要关注的是Android 4.4(“KitKat”). 之前的系统以不同的方式工作，未来的版本也会不同。特定版本的特性会很少并会指出。</p>
<p>我会在很多地方引用AOSP资源或者Grafika. Grafika是一个谷歌为了测试而开源的项目；存放在<a href="https://github.com/google/grafika" target="_blank" rel="external">github grafika</a>.这比具体的实例代码更易修改(quick hack)，但这就足够了。</p>
<h2 id="BufferQueue_and_gralloc_（BufferQueue和gralloc）">BufferQueue and gralloc （BufferQueue和gralloc）</h2><p>为了理解Android图形系统如何工作，我们必须从屏幕后开始。Android中所有图形的核心是<code>BufferQueue</code>类。它的角色很简单：联系一些图形数据生产者(producer)的通用缓存，传递给一些需要这些数据用于展示或进一步处理的消费者(consumer)。生产者和消费者可以存在不同进程中。几乎所有在系统中移动的图形数据都依赖<code>BufferQueue</code>。</p>
<p>基本使用很简单。生产者请求一个空缓冲区(<code>dequeueBuffer()</code>)，指明一组包含宽、高像素格式、使用标志的特征信息。生产者传递该缓冲区，返回给队列(<code>queueBuffer()</code>)。一段时间以后，消费者获取到缓存区(<code>acquireBuffer()</code>)然后使用其中的内容。当消费者处理完成后，将缓冲区返回给队列(<code>releaseBuffer()</code>)。</p>
<p>最近绝大多数Android设备都支持同步框架(sync framework)。其允许系统漂亮的完成一些和硬件系统相关的操作，异步操作图形数据。例如一个生产者提交了一系列OpenGL ES绘图命令，然后将输出缓冲区在渲染完成之前入队列。当内容准备好时，缓冲区伴随着栅栏信号(by a fence that signals)。当返回给空闲列表时第二个栅栏伴随着缓冲区，所以消费者可以释放缓冲区，与此同时内容仍然正在使用中。这种方法提高了缓冲通过系统的延迟和吞吐量。</p>
<p>队列的一些特点是由生产者和消费者共同确定的，比如它所能容纳的缓冲区的最大数量。</p>
<p><code>BufferQueue</code>因为需要缓冲区，所以负责它们的分配。除非改变缓冲区中的特征信息，否则其不会改变；例如，如果生产者开始请求一个不同大小的缓冲区，老缓冲区会被释放掉，然后根据需求分配新的缓冲区。</p>
<p>数据结构目前总是被消费者创建和“拥有”。在Android 4.3中，只有生产者是被束缚(binderized)的，也就是生产者可以在别的进程中，但是消费者必须在队列创建的进程。这个情况在4.4中变成了更加通用的实现。</p>
<p>缓冲区内容永远不会被<code>BufferQueue</code>复制。移动这么多的数据会非常低效。相反，缓冲区总是通过句柄(passed by handle)传递。</p>
<h3 id="gralloc_HAL">gralloc HAL</h3><p>真实的缓冲区分配是由内存分配器”galloc”操作，它实现了一个特定提供商(vendor-specific)的HAL接口(查看<a href="https://android.googlesource.com/platform/hardware/libhardware/+/kitkat-release/include/hardware/gralloc.h" target="_blank" rel="external">gralloc.h</a>)。<code>alloc()</code>函数接收你希望得到的参数：宽度、高度、像素格式、一系列的使用标志。这些标志位值得进一步关注。</p>
<p><code>gralloc</code>分配器不仅仅是在原生堆(native heap)分配内存的另一种方法。在一些情况下，分配内存可能不是缓存一致(cache-coherent)，或者可能在用户空间完全无法访问。分配的性质是由标志位确定的,其中包括属性:</p>
<ul>
<li>软件能够进入的频率(CPU)</li>
<li>硬件能够进入的频率(GPU)</li>
<li>内存是否将被用作OpenGL ES(GLES)的纹理</li>
<li>内存是否将被用作视频编码器</li>
</ul>
<p>例如，如果你的格式指定RGBA 8888像素，你指明缓冲区可以通过软件接入，意味着你的应用将会直接操作像素，然后分配器会创建一个每像素4个字节、按照R-G-B-A排序的缓冲区。如果你指明缓冲区只能作为GLES纹理通过硬件进入，分配器将会遵循GLES驱动的任意要求–BGRA排序，非线性“狂饮”(swizzled)布局，替换颜色格式。允许硬件使用它的首选格式可以提高性能。</p>
<p>一些值在特定平台下无法组合。例如，”视频编码器”标志位可能要求YUV像素，所以添加”软件访问”然后指明RGBA 8888时就会失败。</p>
<h2 id="SurfaceFlinger_and_Hardware_Composer_（SurfaceFlinger和硬件设计者）">SurfaceFlinger and Hardware Composer （SurfaceFlinger和硬件设计者）</h2><p>图形数据有缓存区非常棒，但是当你在设备上看到他们的时候生活会更美好。所以就需要SurfaceFlinger和硬件设计者HAL。</p>
<p>SurfaceFlinger的任务是接收来自多个源的数据缓冲区，混合它们，然后再展示它们。很久以前，我们通过软件把数据传送(blitting)给硬件帧缓冲区(例如 <code>/dev/graphics/fb0</code>)，但是早就不这样做了。</p>
<p>当app被展示的时候，WindowManager服务请求SurfaceFlinger来绘制外观。SurfaceFlinger创建了层(layer)–这是一个BufferQueue的主要组成部分，此时SurfaceFlinger变成了消费者。一个绑定生产者的对象从WindowManager传递给app，之后就可以直接给SurfaceFlinger传递帧。(注意：WindowManager使用”window”术语代替”layer”，然后使用”layer”指代其他东西。我们会采用SurfaceFlinger的术语。这可能会引起争论，SurfaceFlinger应该叫做LayerFlinger)。</p>
<p>对绝大多数应用来说，任何时候屏幕上都会有三个layer：屏幕顶部的状态栏”status bar”，底部或旁边的导航栏”navigation bar”，和应用的UI。一些应用会更多或更少，例如默认的home应用因为墙纸有了独立的layer，而全屏游戏可能隐藏状态栏。每一个layer都可以独立的更新。状态栏、导航栏通过系统进程渲染，应用的layer由其自己渲染，两者之间没有协调。</p>
<p>设备通过一个固定的频率刷新显示，在手机和平板上通常是每秒60帧。如果显示内容时是中等速度(mid-refresh)，就有可能看到撕裂(tearing);所以只在循环间更新内容是很重要的。当更新内容安全时系统会接收信号。因为历史原因，我们称其为VSYNC信号。</p>
<p>当收到VSYNC信号时，SurfaceFlinger遍历layer列表查找新的缓冲区。如果找到，就获取它；如果没有，继续使用之前获取到的缓冲区。SurfaceFlinger总是希望展示些东西，所以他会紧紧抓住一个缓冲区。如果一个layer从未提交过一个缓冲区，那么该layer就会被忽略。</p>
<p>一旦SurfaceFlinger收集到了可视layer的所有缓冲区，它就会询问硬件设计者如何执行合成(how composition should be performed)。</p>
<h3 id="Hardware_Composer_硬件设计">Hardware Composer 硬件设计</h3><p>硬件设计HAL(HWC)最初在Android 3.0引入，这些年稳步发展。主要目的是使用可用硬件确定合成缓冲区最有效的方法。HAL完成的是特定设备，通常由显示硬件OEM完成。</p>
<p>当你考虑“重叠层”(overlay planes)时很容易就认识到这种方法的价值。重叠层的目的是合成多个缓冲区，但是始终显示硬件中而非GPU。例如，假设你有一个典型的Android手机现在是竖屏模式，顶部是状态栏，底部是导航栏，app内容在其他地方。每个layer的内容都在各自的缓冲区中。你可以通过渲染app内容到一个草稿缓冲区来操作合成内容，然后渲染状态栏覆盖它，然后在最顶层渲染导航条，最终把草稿缓冲区传递给显示硬件。或者你可以传递三个缓冲区给显示硬件，告诉它为屏幕中的三个部分的显示从三个不同的缓冲区读取数据。后一种方法明显更有效。</p>
<p>正如你料想的一样，不同显示处理器的能力大相径庭。很难通过一个API传递重叠层的数量、layer是否可以旋转或混合、限制定位和重叠。所以HWC像下面一样工作：</p>
<ol>
<li>SurfaceFlinger给HWC提供所有的layer列表，然后询问，”你将如何处理这些layer?”</li>
<li>HWC通过标记每一层为”overlay”或者”GLES composition”分别响应询问。</li>
<li>SurfaceFlinger负责任意的GLES合成，传递输出缓冲区到HWC，其余的交给HWC处理。</li>
</ol>
<p>自从可以通过硬件供应商定制决策代码，每个设备就有可能得到最佳性能。</p>
<p>当屏幕上没有什么改变的时候，重叠层(overlay planes)可能没有GL合成高效。当重叠层有透明像素的时候就特别明显，重叠层被混合在一起。这种情况下，HWC可以选择为一些或全部的层请求GLES合成并保持合成缓冲区。如果SurfaceFlinger重新回来请求合成相同缓冲区，HWC可以仅仅继续展示之前的合成草稿缓冲区。这样可以提升空闲设备的电池寿命。</p>
<p>出货的Android 4.4设备通常支持四个重叠层。试图合成多层而不是使用重叠( than there are overlays)将导致系统使用GLES组成了他们中的一些层;所以app使用层的数量对耗电量和性能有很大影响。</p>
<p>你可以使用<code>adb shell dumpsys SurfaceFlinger</code>查看SurfaceFlinger到底做了什么。会输出很多冗余信息(verbose)。和我们讨论的部分最相关的出现在输出信息底部的HWC总结。</p>
<p>从中可以得知屏幕上展示了什么层，不论你是使用覆盖层(HWC)还是OpenGLES合成(GLES)，显示了一堆你可能不在意的信息(“handle”、”hints”和”flags”和其他一些东西在上面的图表中已经被我们去除了)。”source crop”和”frame”值稍后会更详细的介绍。</p>
<p>该FB_TARGET层就是GLES合成的输出。因为上面显示的所有层都使用覆盖层，FB_TARGET在这帧中并未使用。层的名字揭示了它们的作用：在一个没有覆盖层的<code>/dev/graphics/fb0</code>中的设备，所有合成都会由GLES完成，输出到framebuffer. 最新的设备上通常没有简单的帧缓冲(framebuffer)，所以FB_TARGET层是一个草稿缓冲区。(注意：这就是为什么旧版本的Android而写的屏幕抓取器不再起作用的原因：它们试图从并不存在的Framebuffer中读取信息)。</p>
<p>重叠层有其他重要作用：只有他们能显示DRM内容。DRM保护缓冲区不能由SurfaceFlinger或GLES驱动访问，这就意味着如果HWC切换到GLES合成的时候视频将会消失。</p>
<h3 id="The_Need_for_Triple-Buffering_三重缓冲的需求">The Need for Triple-Buffering 三重缓冲的需求</h3><p>为了避免屏幕撕裂，系统需要双重缓冲：前面的缓冲用来展示，后面的缓冲用来准备。收到VSYNC的时候，如果后面的缓冲区准备好了，就马上切换它们。在你直接向帧缓存系统绘图的时候该系统工作的相当不错，但在整个工作流中添加合成步骤的时候会有问题。因为SurfaceFlinger被触发了，我们的双缓冲管道将会有泡沫。（？？）</p>
<p>假设帧N正在显示，SurfaceFlinger请求帧N+1用来在VSYNC到来的时候显示。(假设帧N和一个重叠层合成，所以知道显示完成，否则不能改变缓冲区内容。)当收到VSYNC的时候，HWC翻转缓冲区。当app开始向缓冲区提供帧N+2，该缓冲区之前用来保存帧N，SurfaceFlinger扫描层列表，查找更新。SurfaceFlinger找不到任何一个新的缓冲区，所以准备在下一个VSYNC到的时候重新显示帧N+1。稍后APP完成了渲染帧N+2，将其插入SurfaceFlinger队列，但是已经太晚了。这样我们的最大帧率被削减了一半。</p>
<p>可以通过三重缓冲修复这个问题。在VSYNC之前，帧N显示出来，帧N+1被合成（或者安排一个重叠层）准备好了被显示，帧N+2入队，准备被SurfaceFlinger请求。当屏幕翻转的时候，缓冲区没有泡沫通过旋转阶段。该应用程序完成渲染和队列缓冲区刚刚少于一个完整的VSYNC周期（60fps下16.7毫秒）。而SurfaceFlinger/HWC有一个完整的VSYNC周期在下一次翻转前计算出合成。缺点是不论app为屏幕显示做了什么事都至少需要两个VSYNC周期。随着延迟增加，设备响应触摸输入会越来越慢。</p>
<p><img src="http://i.imgur.com/HdxZAia.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-20150407arcmenu" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/07/20150407arcmenu/" class="article-date">
  	<time datetime="2015-04-07T02:03:37.000Z" itemprop="datePublished">4月 7 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/07/20150407arcmenu/">Android自定义组件：弧形菜单</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自定义属性<br>读取自定义属性<br>测量组件<br>放置组件<br>设置相应事件<br>属性集合</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-20150325" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/25/20150325/" class="article-date">
  	<time datetime="2015-03-25T06:40:57.000Z" itemprop="datePublished">3月 25 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/25/20150325/">Android Studio和Genymotion的配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一段时间没有做原生Android，再回头一看，谷歌官网都已经没有adt bundle下载了……全都换成Android Studio，这样也就只能自我升级学习新技术了。</p>
<blockquote>
<p>运行平台<br>Windows 7 Ultimate sp1 x64<br>128G ssd<br>6G RAM</p>
</blockquote>
<h1 id="Android_Studio_安装">Android Studio 安装</h1><p>如果不算网络情况的话，全流程没有任何难度，最大的主题就是下载！下载！下载！</p>
<p>安装好Android Studio后首次启动依旧会更新SDK，所以仍然需要联网，稍有不慎就挂了，需要从头更新。</p>
<h1 id="Genymotion_配置">Genymotion 配置</h1><p>这是一个挺火的虚拟机，一段时间的使用后发现，即使Android Studio自带的虚拟机有了VT技术，genymotion比它快的也不是一星半点，完全不在同一个级别。而且genymotion还有Android Studio的插件，配合起来用非常顺手，所以理所当然代替了自带虚拟机。</p>
<h2 id="注册、下载">注册、下载</h2><p>下载Genymotion必须先注册<br><a href="http://www.genymotion.net/" target="_blank" rel="external">官网注册</a></p>
<p>必须注册、登陆后，才能看到下载地址</p>
<h2 id="配置">配置</h2><p>安装完成后，会需要使用之前注册的账号登陆，才能下载虚拟机，你木有看错，安装完成的genymotion只包含了一个测试机，建议删除，重新下载！下载！下载！ </p>
<h2 id="使用">使用</h2><p>第一次在Android Studio工具栏点击genymotion的按钮，会提示选择genymotion的安装路径。</p>
<p>以后启动genymotion虚拟机就可以直接点击按钮。然后运行APP的时候选择已经存在的虚拟机即可。</p>
<p>之后运行的时候如果报错虚拟机的网络问题，有两个解决方法</p>
<ol>
<li>genymotion是基于VirtualBox的，所以修改VirtualBox的网卡，设置为DHCP</li>
<li>用管理员权限打开Android Studio</li>
</ol>
<p>这样就可以解决提示的网络问题，目前还没有遇到其他问题。</p>
<p>PS：</p>
<p>如果使用Android Studio的原生虚拟机，有可能提示</p>
<pre><code>Haxm can <span class="keyword">not</span> be installed <span class="keyword">until</span> VT-X  <span class="keyword">is</span> enables.
</code></pre><p>这样除了打开BIOS里面的<code>Intel Virtualization Technology</code>为<code>enable</code>，还应该执行<code>%ANDROIDSDK%\Android\sdk\extras\intel\intelhaxm-android.exe</code>,这样才能正常启动自带虚拟机。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-20150320" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/20/20150320/" class="article-date">
  	<time datetime="2015-03-20T07:53:20.000Z" itemprop="datePublished">3月 20 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/20/20150320/">return true</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一个悲伤的故事。</p>
<p>这是一个由<code>return true</code>引发的惨案。</p>
<p>这是一个基础不扎实的悲剧。</p>
<p>事情的原因是最近又手痒搞起Android，发现一个新教程的思路去实现下拉刷新功能。所以就动手实现以下。但是实现好了以后发现有问题，以为是自己的问题，但是切换为教程里的源码后仍然出错，这就果断悲剧….所以只能一步步调试。</p>
<p>中间过程极其痛苦，因为不论怎么检查，逻辑都是没有问题的，期间排除了很多我以为导致出错的原因：</p>
<ol>
<li>依照状态进行判断，和依照移动距离进行判断其实是一样的</li>
<li>不是由看到第一个item的时候设置标志位引起的滞后</li>
<li>不是由topPadding变大以后引起的计算距离问题</li>
<li>不是ev.getY()和ev.getRawY()区别引起的问题</li>
</ol>
<p>最后无数次尝试，发现了问题在于<code>onTouchEvent</code>中处理之后应该返回<code>return true;</code></p>
<pre><code>onTouchEvent() {
    switch (ev<span class="built_in">.</span>getAction()) {
    <span class="attribute">...</span><span class="attribute">...</span>
    <span class="keyword">case</span> MotionEvent<span class="built_in">.</span>ACTION_MOVE :
        <span class="attribute">...</span><span class="attribute">...</span>
        <span class="keyword">if</span> () {
            <span class="attribute">...</span><span class="attribute">...</span>
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
    break;
    <span class="attribute">...</span><span class="attribute">...</span>
}
</code></pre><p>下面就是如果不添加<code>return true;</code>的后果，可以明显看到，触摸没有回到原位的时候，顶部header早已缩回屏幕上方：</p>
<p><img src="http://i.imgur.com/S1vnv1c.gif" alt=""></p>
<p>至于背后的原理，等我下次再详细总结Android的touch事件。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/touch/">touch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015021401" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/14/2015021401/" class="article-date">
  	<time datetime="2015-02-14T02:06:37.000Z" itemprop="datePublished">2月 14 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/14/2015021401/">自定义Android视图(04/04)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Optimizing_the_View_优化view">Optimizing the View 优化view</h1><p>现在你有了一个精心设计的视图，可以处理相应手势和在不同状态间转场，你需要确保视图运行很快。为了避免UI感觉迟钝或者回放时卡顿，你必须确保你的动画一直保持每秒60帧(ensure that your animations consistently run at 60 frames per second)。</p>
<h2 id="Do_Less,_Less_Frequently_做的更少，经常更少？">Do Less, Less Frequently 做的更少，经常更少？</h2><p>移除那些经常调用的函数中不必要的代码来加速你的视图。从<code>onDraw()</code>下手将会获得最大收益。特别的，你应该移除<code>onDraw()</code>中的分配(allocations)资源，因为分配资源可能导致垃圾回收，进而带来卡顿。在初始化时或动画之间分配对象，永远不要在动画运行的时候分配资源。</p>
<p>近一步使<code>onDraw()</code>更精简，你应该确保它尽可能少的被调用。大多数调用<code>onDraw()</code>的结果是调用<code>invalidate()</code>，所以减少不必要的调用<code>invalidate()</code>. 如果可能，调用有四个参数的<code>invalidate()</code>版本，而不是无参数的<code>invalidate()</code>. 无参数的版本使整个view失效，而四个参数的版本只会使指明的部分失效。这个方法可以使绘制更有效，避免清除失效矩阵外非的其他视图。</p>
<p>其他非常耗时的操作是遍历布局。任何时候视图调用<code>requestLayout()</code>，Android UI系统需要遍历整个view结构来确认每个视图的尺寸。如果找到冲突的尺寸，它需要多次遍历。UI设计者有时创建嵌套的<code>ViewGroup</code>对象使得UI表现正确。这些深层视图结构会引起性能问题。确保你的视图结构尽可能的少。</p>
<p>如果你有一个复制的UI，你应该考虑用一个自定义的<code>ViewGroup</code>来实现布局。和原生的视图不同，你的自定义视图可以根据特定应用程序(application-specific)来设定其子结构的大小和形状的，这样就可以避免遍历其子结构来计算尺寸。<code>PieChart</code>例子展示了如何拓展<code>ViewGroup</code>作为自定义视图的一部分。<code>PieChart</code>有子视图，但是从未测量过它们。相反的，它根据自己的布局算法直接设置子视图的大小。</p>
<h2 id="Use_Hardware_Acceleration_使用硬件加速">Use Hardware Acceleration 使用硬件加速</h2><p>对Android 3.0来说，Android 2D图形系统可以通过GPU加速。GPU在最新的Android设备中都能找到。GPU硬件加速可以为很多应用带来极大的性能提升，但它不一定适用于任何一个程序。Android框架赋予你可以控制应用中哪些部分使用硬件加速的能力。</p>
<p>查看<a href="http://developer.android.com/guide/topics/graphics/hardware-accel.html" target="_blank" rel="external">硬件加速章节</a>获取更多信息。注意，除了开发者指导中提到的方面以外，你必须在 <code>AndroidManifest.xml</code>中指明<code>&lt;uses-sdk android:targetSdkVersion=&quot;11&quot;/&gt;</code>来设置程序的目标API高于11级。</p>
<p>启动了硬件加速后，你有可能看不到性能的提升。移动GPU在特定的任务中是非常高效的，例如绘制直线和曲线。为了获取GPU加速的极致性能，你应该在GPU擅长的地方尽量使用它，在其不擅长的地方尽量避免使用。</p>
<p>在<code>PieChart</code>例子中，绘制饼图是相对来说耗时的。旋转饼图引起的每次重绘UI都会感觉迟钝。解决办法是放置图标到一个子视图，然后设置视图的布局类型是<code>LAYER_TYPE_HARDWARE</code>，这样GPU就会将其缓存为一个静态图像。该例子定义子视图作为<code>PieChart</code>的内部类，这样可以为实现该方法改动尽量少的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PieView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PieView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context);</span><br><span class="line">       <span class="keyword">if</span> (!isInEditMode()) &#123;</span><br><span class="line">           setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Item it : mData) &#123;</span><br><span class="line">           mPiePaint.setShader(it.mShader);</span><br><span class="line">           canvas.drawArc(mBounds,</span><br><span class="line">                   <span class="number">360</span> - it.mEndAngle,</span><br><span class="line">                   it.mEndAngle - it.mStartAngle,</span><br><span class="line">                   <span class="keyword">true</span>, mPiePaint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">       mBounds = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RectF mBounds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在代码改变后，<code>PieChart.PieView.onDraw()</code>只会在图形第一次展示的时候调用，在APP余下的生命周期中，图标被缓存为一个图片，由GPU重新绘制它的不同旋转角度。GPU硬件特别擅长这类事，性能马上就会不同。</p>
<p>这是一个折中方案。将图像在硬件层缓存会消耗图像存储器，而其资源有限。因为这个原因，最终版的<code>PieChart.PieView</code>只是在用户真正旋转的时候才设置它的布局类型为<code>LAYER_TYPE_HARDWARE</code>。在其余时间，它设置布局类型为<code>LAYER_TYPE_NONE</code>，这将使得GPU不再缓存图像。</p>
<p>最后，不要忘记给代码写概要(profile your code)。一个视图提升性能的技巧可能对另一个视图来说会带来性能下降。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015021101" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/11/2015021101/" class="article-date">
  	<time datetime="2015-02-11T02:20:23.000Z" itemprop="datePublished">2月 11 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/11/2015021101/">自定义Android视图(03/04)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Making_the_View_Interactive_让view可以交互">Making the View Interactive  让view可以交互</h1><p><a href="http://developer.android.com/training/custom-views/making-interactive.html" title="原文链接" target="_blank" rel="external">原文链接</a></p>
<p>绘制UI只是自定义视图的一部分。你同样需要使你的视图以接近（closely resembles）现实世界的行为方式响应用户输入。对象应当一直和真实对象的行为一致。例如图像不应该从所在地方立即弹出然后重新出现在其他地方，因为真实世界的对象不会这样。相反，图像应该从一个地方移动到另一个地方。</p>
<p>使用者在交互的过程中会感受到微妙的行为或感受，然后和模拟真实世界进行最佳互动。例如当使用者投掷（滑动？fling）一个UI对象，刚开始他们应该感受到因摩擦而引起的运动延迟，最后感觉到运动的动能超越滑动( sense momentum that carries the motion beyond the fling)。</p>
<p>这节课演示如何使用Android框架的特性来为自定义属性增加真实世界的行为。</p>
<h2 id="Handle_Input_Gestures_处理输入手势">Handle Input Gestures 处理输入手势</h2><p>同许多其他UI框架一样，Android支持输入事件模型。用户的行为转化为时间最终触发回调，你可以重载回调来自定义应用如何应对用户的输入。</p>
<p>Android系统中最常见的输入事件是touch，它会触发<code>onTouchEvent(android.view.MotionEvent)</code>.重载这个方法来处理事件</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onTouchEvent</span><span class="params">(event)</span></span>;
}
</code></pre><p>触摸事件本身并不是特别有用。现代的UI触摸定义交互手势：点击tapping，拉pulling，推pushing，投掷flinging，缩放zooming. Android提供<code>GestureDetector</code>将原始的touch事件转换为手势(gesture)。</p>
<p>通过传递一个<code>GestureDetector.OnGestureListener</code>类的实例作为参数构造<code>GestureDetector</code>.如果你只是希望处理少数手势，你可以拓展<code>GestureDetector.SimpleOnGestureListener</code>而非实现<code>GestureDetector.OnGestureListener</code>接口。下面的代码创建了一个拓展 <code>GestureDetector.SimpleOnGestureListener</code><br>并重载<code>onDown(MotionEvent)</code>方法的类</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">mListener</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> {</span>
   <span class="annotation">@Override</span>
   public boolean onDown(<span class="type">MotionEvent</span> e) {
       <span class="keyword">return</span> <span class="literal">true</span>;
   }
}

mDetector = <span class="keyword">new</span> <span class="type">GestureDetector</span>(<span class="type">PieChart</span>.<span class="keyword">this</span>.getContext(), <span class="keyword">new</span> mListener());
</code></pre><p>无论是否使用<code>GestureDetector.SimpleOnGestureListener</code>，你都应该实现一个<code>return ture;</code>的<code>onDown()</code>方法。这一步是必要的，因为所有手势都从<code>onDown()</code>消息开始。如果你像<code>GestureDetector.SimpleOnGestrueLinstener</code>一样在<code>onDown()</code>中返回<code>false</code>，系统假设你希望忽略余下的手势（If you return false from onDown(), as GestureDetector.SimpleOnGestureListener does, the system assumes that you want to ignore the rest of the gesture），其余<code>GestureDetector.OnGestrueListener</code>的方法将永远不会被执行。只有你在真正希望忽略整个手势的时候才应该在<code>onDown(</code>)中返回<code>false</code>。一旦你实现了<code>GestureDetector.OnGestureListener</code>，并且创建了<code>GestrueDetector</code>的实例，你就能使用<code>GestureDetector</code>和在<code>onTouchEvent()</code>中收到的touch事件交互。</p>
<pre><code>@<span class="type">Override</span>
public boolean onTouchEvent(<span class="type">MotionEvent</span> event) {
   boolean <span class="literal">result</span> = mDetector.onTouchEvent(event);
   <span class="keyword">if</span> (!<span class="literal">result</span>) {
       <span class="keyword">if</span> (event.getAction() == <span class="type">MotionEvent</span>.<span class="type">ACTION_UP</span>) {
           stopScrolling();
           <span class="literal">result</span> = <span class="literal">true</span>;
       }
   }
   <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>当你传递给<code>onTouchEvent()</code>一个未被确认手势的touch事件是，它返回<code>false</code>.你就可以运行自定义的手势检测代码。</p>
<h2 id="Create_Physically_Plausible_Motion_创建物理合理(plausible)的行为">Create Physically Plausible Motion 创建物理合理(plausible)的行为</h2><p>手势是控制触摸屏的有力工具，除非他们的结果在物理上是合理的，否则就有可能反直觉、难以记忆。一个好的例子是fling手势：用户快速跨越屏幕移动手指然后离开屏幕。如果UI响应是和滑动方向一致的快速移动，然后减速，这个手势才有道理，就像用户推动了飞轮（flywheel）使其旋转。</p>
<p>然而，模拟飞轮的感觉并非微不足道(trivial)。让飞轮模型正确工作需要很多物理和数学知识。幸运的是，Android提供辅助类来模拟这些行为。<code>Scroller</code>类是处理飞轮风格fling手势的基础。</p>
<p>开始一个fling，调用<code>fling()</code>传入fling的初始速度和最大、最小的x、y值。对于速度值，可以使用<code>GestureDetector</code>为你计算这个值。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>{
   mScroller.fling(currentX, currentY, velocityX / SCALE, velocityY / SCALE, minX, minY, maxX, maxY);
   postInvalidate();
}
</code></pre><p>注意：虽然通过<code>GestureDetector</code>计算速度物理上来说是精确的，但是很多开发者感觉使用这个值来fling动画会太快。通常把x、y速度除以4或8.</p>
<p>调用<code>fling()</code>设置fling手势的物理模型。无论如何，你需要用<code>Scroller.computeScrollOffset()</code>来定期更新Scroller. <code>computeScrollOffset()</code>通过读取当前时间，使用物理模型计算那时的x、y位置来更新Scroller对象内部状态。调用<code>getCurrX()</code>和<code>getCurrY()</code>来获取这些值。</p>
<p>大多数视图通过直接调用<code>scrollTo()</code>传递Scroller对象的x、y值。PieChart例子有一点不同：它使用当前滚动的y值来设置图标的旋转角度。</p>
<pre><code><span class="keyword">if</span> (!mScroller.isFinished<span class="literal">()</span>) {
    mScroller.computeScrollOffset<span class="literal">()</span>;
    setPieRotation(mScroller.getCurrY<span class="literal">()</span>);
}
</code></pre><p>Scroller类为你计算滚动位置，但是它不会自动对自定义视图应用这些位置。确保尽可能多(often enough)的得到、应用新坐标，使滚动动画看起来很顺畅是你的责任。有两种方法做到这些：</p>
<ul>
<li>为了强制重新绘制，调用<code>fling()</code>之后再调用<code>postInvalidate()</code>. 这个技巧要求每次滚动偏移改变的时候在<code>onDraw()</code>中计算滚动偏移，然后调用<code>postInvalidate()</code>.</li>
<li>设置<code>ValueAnimator</code>使fling的过程顺畅，然后调用<code>addUpdateListener()</code>来添加监听器处理动画。</li>
</ul>
<p>PieChart使用第二个方法。这个技巧设置更复杂，但是和动画系统配合的更密切，而且不需要使潜在的非必须视图失效(view invalidation)。缺点是<code>ValueAnimator</code>在API 11之前不可用，所以这个技巧在运行低于3.0系统的设备上无法使用。</p>
<p>注意：<code>ValueAnimator</code>在低于API 11时无法使用，但是你仍然可以在那些平台使用。你只需要确保在运行时检查当前API等级，然后如果等级低于11时，忽略调用视图动画系统。</p>
<pre><code>mScroller = <span class="keyword">new</span> Scroller(getContext(), <span class="keyword">null</span>, <span class="keyword">true</span>);
mScrollAnimator = ValueAnimator.ofFloat(<span class="number">0</span>,<span class="number">1</span>);
mScrollAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() {
   <span class="annotation">@Override</span>
   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>{
       <span class="keyword">if</span> (!mScroller.isFinished()) {
           mScroller.computeScrollOffset();
           setPieRotation(mScroller.getCurrY());
       } <span class="keyword">else</span> {
           mScrollAnimator.cancel();
           onScrollFinished();
       }
   }
});
</code></pre><h2 id="Make_Your_Transitions_Smooth_让你的转场更流畅">Make Your Transitions Smooth 让你的转场更流畅</h2><p>用户希望现代UI在不同状态间流畅的转场。UI元素淡入淡出而非直接出现、消失。运动流畅的开始、结束，而非突然开始、停止。Android属性动画框架( property animation framework)，在Android 3.0时引入，使得流畅转场很容易。</p>
<p>当一个可能影响视图外观的property改变时，不要直接改变该property。相反，应该使用<code>ValueAnimator</code>来做这些改变。接下来的列子，修改PieChart当前选择的切块，引起整个图标的旋转，选择指针指向被选中的切片中间。<code>ValueAnimator</code>在几百毫秒的跨度里改变旋转，而不是直接设置新旋转的值。</p>
<pre><code>mAutoCenterAnimator = ObjectAnimator.ofInt(PieChart.this, "PieRotation", 0)<span class="comment">;</span>
mAutoCenterAnimator.setIntValues(targetAngle)<span class="comment">;</span>
mAutoCenterAnimator.setDuration(AUTOCENTER_ANIM_DURATION)<span class="comment">;</span>
mAutoCenterAnimator.start()<span class="comment">;</span>
</code></pre><p>如果你想改变的是view的基本property，使用动画会更简单，因为视图有一个内建的<code>ViewPropertyAnimator</code>，它会优化多个改变属性时的模拟动画。例如：</p>
<pre><code><span class="tag">animate</span>()<span class="class">.rotation</span>(<span class="tag">targetAngle</span>)<span class="class">.setDuration</span>(<span class="tag">ANIM_DURATION</span>)<span class="class">.start</span>();
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015021001" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/10/2015021001/" class="article-date">
  	<time datetime="2015-02-10T02:29:00.000Z" itemprop="datePublished">2月 10 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/10/2015021001/">自定义Android视图(02/04)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Custom_Drawing_自定义绘图">Custom Drawing 自定义绘图</h1><p>自定义视图中最重要的部分是其外观。自定义绘图的复杂性会根据你的APP而定。这节将会覆盖最常用的操作。</p>
<h2 id="Override_onDraw()_重载onDraw()">Override onDraw()  重载onDraw()</h2><p>绘制自定义视图最重要的部分就是重载<code>onDraw()</code>方法。<code>onDraw()</code>的参数是一个view可用来绘制自己的Canvas对象。</p>
<p>Canvas类定义了方法来绘制文字、线条、位图和其余很多图元（graphics primitives 基本图形）。<br>可以在onDraw()中使用这些方法来绘制自己的UI。</p>
<p>在调用任何绘制方法前，应该创建Paint对象。下节将详细介绍Paint.</p>
<h2 id="Create_Drawing_Objects_创建绘制对象">Create Drawing Objects 创建绘制对象</h2><p><code>android.graphics</code>框架将绘图分为两部分：</p>
<ul>
<li>画什么，用Canvas控制</li>
<li>怎么画，用Paint控制</li>
</ul>
<p>例如，Canvas提供了方法绘制直线，同时Paint提供定义直线颜色的方法。Canvas有方法绘制矩形，<br>Paint定义是否对其填充颜色。简单来说，Canvas定义你可以绘制的形状，Paint定义绘制图形的颜色、样式、字体。</p>
<p>在你绘制任何东西之前，你需要创建一个或多个Paint对象。PieChart例子通过init()来实现，通过构造函数来调用。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
   mTextPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);
   mTextPaint.setColor(mTextColor);
   <span class="keyword">if</span> (mTextHeight == <span class="number">0</span>) {
       mTextHeight = mTextPaint.getTextSize();
   } <span class="keyword">else</span> {
       mTextPaint.setTextSize(mTextHeight);
   }

   mPiePaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);
   mPiePaint.setStyle(Paint.Style.FILL);
   mPiePaint.setTextSize(mTextHeight);

   mShadowPaint = <span class="keyword">new</span> Paint(<span class="number">0</span>);
   mShadowPaint.setColor(<span class="number">0xff101010</span>);
   mShadowPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">8</span>, BlurMaskFilter.Blur.NORMAL));

   ...
</code></pre><p>提前创建对象是一个很重要的优化手段。View会被频繁的重绘，很多绘制对象需要昂贵的初始化。<br>在<code>onDraw()</code>中创建绘制对象将会降低性能，使UI出现卡顿。</p>
<h2 id="Handle_Layout_Events_处理布局事件">Handle Layout Events 处理布局事件</h2><p>为了妥善的绘制自定义视图，你需要知道它的尺寸。复杂的自定义视图通常会根据它在屏幕上区域的大小和尺寸进行多次布局计算。永远不要假设你的视图在屏幕上的大小。即使只有一个app使用你的view，该app需要处理不同屏幕尺寸，多个屏幕密度，水平、垂直模式下的不同高宽比。</p>
<p>虽然view有很多方法处理尺寸问题，但是它们中的绝大多数不需要被重载。如果你的视图不需要特别控制其大小，就只需要重载一个方法：<code>onSizeChanged()</code></p>
<p><code>onSizeChanged()</code>在你的视图第一次分配尺寸的时候被调用，之后任何原因引起视图尺寸改变都会调用它。在<code>onSizeChanged()</code>中计算位置、维度、和其他与视图相关的值，避免每次绘制的时候重复计算。<br>在PieChart例子中，PieChart视图在<code>onSizeChanged()</code>中计算边框矩形、相对位置、文本标签和其他视觉元素</p>
<p>当你的视图分配了一个大小，布局管理假设该尺寸包含此视图的所有padding。<br>当你计算视图尺寸的时候须处理padding值。<code>PieChart.onSizeChanged()</code>的例子：</p>
<pre><code><span class="comment">// 计算 padding</span>
<span class="keyword">float</span> xpad = (<span class="keyword">float</span>)(getPaddingLeft() + getPaddingRight());
<span class="keyword">float</span> ypad = (<span class="keyword">float</span>)(getPaddingTop() + getPaddingBottom());

<span class="comment">// 计算 label</span>
<span class="keyword">if</span> (mShowText) xpad += mTextWidth;

<span class="keyword">float</span> ww = (<span class="keyword">float</span>)w - xpad;
<span class="keyword">float</span> hh = (<span class="keyword">float</span>)h - ypad;

<span class="comment">// 计算pie能有多大</span>
<span class="keyword">float</span> diameter = Math.<span class="built_in">min</span>(ww, hh);
</code></pre><p>如果你需要更好的控制视图的布局参数，那就实现(implement)<code>onMeasure()</code>方法。该方法的参数是<br><code>View.MeasureSpec</code>，该值会告诉你视图的父节点希望你的视图尺寸是多少，还有这个尺寸是硬性规定的最大值，还是只是一个建议值。为了优化，这些值被加密(pack)存储为整数，使用静态<code>View.MeasureSpec</code>方法解密(unpack)每个整数中的信息。</p>
<p>PieChart 实现<code>onMeasure()</code>，试图创建它的区域足够大来让它的标签尽可能的大</p>
<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
   <span class="comment">// Try for a width based on our minimum</span>
   <span class="comment">// 基于最小值尝试得到宽度</span>
   <span class="keyword">int</span> minw = getPaddingLeft() + getPaddingRight() + getSuggestedMinimumWidth();
   <span class="keyword">int</span> w = resolveSizeAndState(minw, widthMeasureSpec, <span class="number">1</span>);

   <span class="comment">// Whatever the width ends up being, ask for a height that would let the pie</span>
   <span class="comment">// get as big as it can</span>
   <span class="comment">// 无论最终宽度多少，设置高度让pie尽可能的大</span>
   <span class="keyword">int</span> minh = MeasureSpec.getSize(w) - (<span class="keyword">int</span>)mTextWidth + getPaddingBottom() + getPaddingTop();
   <span class="keyword">int</span> h = resolveSizeAndState(MeasureSpec.getSize(w) - (<span class="keyword">int</span>)mTextWidth, heightMeasureSpec, <span class="number">0</span>);

   setMeasuredDimension(w, h);
}
</code></pre><p>代码中有三点需要注意：</p>
<ul>
<li>计算时考虑到了视图的padding。就像之前提到过的，这是视图的责任。</li>
<li>辅助方法<code>resolveSizeAndState()</code>用来创建最终的宽度、高度值。该辅助方法返回一个合适的<br><code>View.MeasureSpec</code>值，通过比较视图希望的大小和传入<code>onMeasure()</code>的详细说明（spec）</li>
<li><code>onMeasure()</code>没有返回值，相反，其通过调用<code>setMeasuredDimension()</code>提交计算结果。调用该方法是强制性的。如果你忽略这个调用，视图类将会抛出一个运行时错误</li>
</ul>
<h2 id="Draw!_绘制">Draw! 绘制</h2><p>一旦你创建对象、测量大小的代码完成了，你就可以实现<code>onDraw()</code>.  每个视图实现的<code>onDraw()</code>都不同，但是有一些绝大多数视图通用的操作：</p>
<ul>
<li>绘制文字用<code>drawText()</code>. 用<code>setTypeface()</code>指明字形，<code>setColor()</code>设置字体颜色。</li>
<li>用<code>drawRect(),drawOval(),drawArc()</code>绘制基础图形。<code>setStyle()</code>设置形状是否被填充、是否有外部轮廓</li>
<li>用Path类创建更复杂的图形。对Path对象定义添加直线、曲线，然后用<code>drawPath()</code>绘制图形。<br>和基础图形一样，可以对用<code>setStyle()</code>对path设置轮廓、填充。</li>
<li>用LinearGradient对象定义渐变填充。调用<code>setShader()</code>将定义的LinearGradient渐变填充至图形。</li>
<li>用<code>drawBitmap()</code>绘制位图</li>
</ul>
<p>例如PieChart中的代码；</p>
<pre><code>protected void onDraw(Canvas <span class="keyword">canvas</span>) {
   super.onDraw(<span class="keyword">canvas</span>);

   <span class="comment">// Draw the shadow</span>
   <span class="comment">// 绘制阴影</span>
   <span class="keyword">canvas</span>.drawOval(
           mShadowBounds,
           mShadowPaint
   );

   <span class="comment">// Draw the label text</span>
   <span class="comment">// 绘制标签文本</span>
   <span class="keyword">canvas</span>.drawText(mData.get(mCurrentItem).mLabel, mTextX, mTextY, mTextPaint);

   <span class="comment">// Draw the pie slices</span>
   <span class="comment">// 绘制pie切块</span>
   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mData.<span class="keyword">size</span>(); ++i) {
       Item it = mData.get(i);
       mPiePaint.setShader(it.mShader);
       <span class="keyword">canvas</span>.drawArc(mBounds,
               <span class="number">360</span> - it.mEndAngle,
               it.mEndAngle - it.mStartAngle,
               true, mPiePaint);
   }

   <span class="comment">// Draw the pointer</span>
   <span class="comment">// 绘制点</span>
   <span class="keyword">canvas</span>.drawLine(mTextX, mPointerY, mPointerX, mPointerY, mTextPaint);
   <span class="keyword">canvas</span>.drawCircle(mPointerX, mPointerY, mPointerSize, mTextPaint);
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2015020201" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/02/2015020201/" class="article-date">
  	<time datetime="2015-02-02T02:37:52.000Z" itemprop="datePublished">2月 2 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/02/2015020201/">自定义Android视图(01/04)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在网上总是搜不到很全面的自定义视图教程，大多数都是抄来抄去，即使买的书中相关内容也不是很多。所以还不如直接自己翻译下官方文档 <a href="http://developer.android.com/training/custom-views/" target="_blank" rel="external">custom views</a>. 一共四篇文章，分步翻译，这是第一篇。</p>
</blockquote>
<h1 id="Creating_a_View_Class_创建一个view类">Creating a View Class  创建一个view类</h1><p>一个精心设计的自定义view像其他精心设计的类一样。它包含一系列特别的功能，拥有简单的用户界面，高效使用CPU和内存等等。为达到这些目的，应该做到：  </p>
<ul>
<li>符合Android标准</li>
<li>提供可以和Android XML通用的自定义属性</li>
<li>支持多个Android平台</li>
</ul>
<p>Android 框架提供了一系列的基础类和XML标签来帮助你达到这些目标。</p>
<h2 id="Subclass_a_View_子类视图">Subclass a View 子类视图</h2><p>所有Android框架中的视图都拓展来自View类。 自定义的视图也可以直接拓展View，或者为了节省时间，拓展一个已经存在的子类，例如Button.</p>
<p>为了让ADT可以和你的view交互，至少要提供一个参数为Context和AttributeSet对象的构造器。该构造器允许布局编辑器创建、编辑自定义view的实例。 </p>
<h2 id="Define_Custom_Attributes_自定义属性">Define Custom Attributes 自定义属性</h2><p>为了在界面中添加一个原生的View，可以在XML元素中声明它，然后通过元素属性控制它的外观和行为。好的自定义view可以允许通过XML增加、改变样式。必须做到如下要求才能在自定义view中实现这些效果:  </p>
<ul>
<li>在&lt;declare-styleable&gt;资源元素中为你的view定义自定义属性 </li>
<li>在XML布局中指明属性的值 </li>
<li>在运行时取回属性数据 </li>
<li>将取回的数据应用在view中  </li>
</ul>
<p>这节将定义、设置属性值，下节将取回、使用这些值。<br>在你的项目中添加<code>&lt;declare-styleable&gt;</code>来定义自定义属性。通常这些自定义的放在<code>res/values/attrs.xml</code>文件中。例如：</p>
<pre><code><span class="tag">&lt;<span class="title">resources</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"PieChart"</span>&gt;</span> 
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"showText"</span> <span class="attribute">format</span>=<span class="value">"boolean"</span> /&gt;</span> 
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"labelPosition"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span> 
            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span> 
            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span> 
        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span> 
    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
</code></pre><p>这段代码声明了两个自定义属性，<code>showText、labelPosition</code>，属于一个可变样式的实体<code>PieChart</code>.<br>可变样式实体的名字通常情况下和自定义view的类名相同。虽然没有严格的要求应该遵循这样的习惯，<br>但是很多流行的代码编辑器依赖这种命名习惯来提供语句结束（statement completion 状态补全？）。 </p>
<p>一旦定义了自定义属性，就能在布局XML文件中像原生属性一样使用它们。唯一的不用<br>在于，你的自定义属性属于不同的命名空间。它们属于<code>http://schemas.android.com/apk/res/[your package name]</code>而非<code>http://schemas.android.com/apk/res/android</code>.<br>举例如何在<code>PieChart</code>中使用为其定义的属性： </p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> 
              <span class="attribute">xmlns:custom</span>=<span class="value">"http://schemas.android.com/apk/res/com.example.customviews"</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">com.example.customviews.charting.PieChart</span> 
        <span class="attribute">custom:showText</span>=<span class="value">"true"</span> 
        <span class="attribute">custom:labelPosition</span>=<span class="value">"left"</span> /&gt;</span> 
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span> 
</code></pre><p>为了避免重复的输入很长的命名URI，上面的例子用了xmlns缩写。这个缩写指明custom是<code>http://schemas.android.com/apk/res/com.example.customviews</code>的别名。<br>你可以为命名空间选择任意的别名。<br>（me:别名是在声明属性时候用的，也就是&lt;&gt;的内部，而不是&lt;&gt;的第一行）<br>注意在布局文件中添加自定义视图的XML tag(&lt;&gt;元素的第一行)的名字。它是自定义view的全路径名。<br>如果你的view类是内部类，就必须用它外部类来补全名字。例如，<code>PieCart</code>类有个内部<br>类<code>PieView</code>. 为了对这个类使用自定义属性，tag就必须使用<code>com.example.customviews.charting.PieChart$PieView</code></p>
<h2 id="Apply_Custom_Attributes_使用自定义属性">Apply Custom Attributes 使用自定义属性</h2><p>当在XML布局中创建view的时候，所有的XML tag都通过资源bundle被读取出来作为<code>AttributeSet</code>参数传递给view的构造函数。虽然有可能直接通过<code>AttributeSet</code>读取值，但是这么做会有以下缺点：</p>
<ul>
<li>属性值中的资源引用是未解析（解码？resolved）的 </li>
<li>样式未被应用 </li>
</ul>
<p>相反的，传递AttributeSet给<code>obtainStyledAttributes()</code>. 这个方法回传一个<code>TypeArray</code>数组，其中的值都已经被dereferenced（间接引用）、styled（样式化）。<br>Android的资源编译器为能轻松调用<code>obtainStyledAttributes()</code>做了大量工作。每个在res目录中的<code>&lt;declare-styleable&gt;</code>资源，生成R.java定义包含属性ids和常量集合（定义在数组中每个属性的索引）的数组。<br>使用预定义常量来通过<code>TypedArray</code>读取属性。举例<code>PieChart</code>类如何读取属性：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{ 
    super(context, attrs); 
    TypedArray a = context.getTheme().obtainStyledAttributes( 
                                        attrs, 
                                        R.styleable.PieChart, 
                                        <span class="number">0</span>, <span class="number">0</span>);     

    <span class="keyword">try</span> { 
        mShowText = a.getBoolean(R.styleable.PieChart_showText, <span class="literal">false</span>); 
        mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, <span class="number">0</span>); 
    } finally { 
        a.recycle(); 
    } 
} 
</code></pre><p>注意TypedArray对象是一个共享资源，必须在使用后recycled.</p>
<h2 id="Add_Properties_and_Events_添加属性和事件">Add Properties and Events 添加属性和事件</h2><p>属性是控制view行为和外观强有力的工具，但是他们只能在view初始化的时候读取。为了提供动态行为，为每一个自定义属性(attribute)公布property getter和setter。举例PieChart如何暴漏(explode)出一个名为showText的property:</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isShowText</span><span class="params">()</span> </span>{ 
    <span class="keyword">return</span> mShowText; 
} 

<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setShowText</span><span class="params">(<span class="keyword">boolean</span> showText)</span> </span>{ 
    mShowText = showText; 
    invalidate(); 
    requestLayout(); 
} 
</code></pre><p>注意<code>setShowText</code>调用了<code>invalidate()</code>和<code>requestLayout()</code>。这些函数对于确保view的可靠表现非常重要。必须在修改view的任何property之后使其无效（invalidate），因为这可能引起外观改变，所以系统就会知道它需要被重绘。比如，如果一个可能影响view的大小或形状property被改变，你就必须请求一个新的布局。忘记调用这些函数可能产生难以调试的问题。 </p>
<p>为和重要的事件沟通，自定义view同样应当支持事件监听。例如PieChart暴漏了一个名为<code>OnCurrentItemChanged</code>自定义事件，来通知监听器用户旋转了饼状图，聚焦在一个新的切块上。 </p>
<p>很容易遗忘公布property和监听器，特别是只有你使用这个自定义视图时。花些时间规划自定义view的接口，就能减少将来维护的成本。<br>一个好的规范是总是公布所有会影响view外观、行为的property。 </p>
<h2 id="Design_For_Accessibility_为易用性设计">Design For Accessibility 为易用性设计</h2><p>你的自定义view应当支持尽可能多的用户。包括那些因为身体残疾无法看到或使用触摸屏的人。<br>为了支持残疾人，你应该遵循下面的规则： </p>
<ul>
<li>用<code>android:contentDescription</code>来标注你的输入框 </li>
<li>适当的时候调用<code>sendAccessibilityEvent()</code>发送无障碍(accessibility)事件 </li>
<li>持替换控制器，例如D-pad 和 trackball </li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Taxus
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: true,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>