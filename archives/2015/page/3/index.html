
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Taxus">
    <title>所有文章: 2015 - Taxus</title>
    <meta name="author" content="Taxus">
    
    
    
    <meta name="description" content="进入前端的后端">
<meta property="og:type" content="blog">
<meta property="og:title" content="Taxus">
<meta property="og:url" content="http://yoursite.com/archives/2015/page/3/index.html">
<meta property="og:site_name" content="Taxus">
<meta property="og:description" content="进入前端的后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Taxus">
<meta name="twitter:description" content="进入前端的后端">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css" type="text/css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">Taxus</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="/#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="2">
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">首頁</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">分類</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">標籤</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">所有文章</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="/#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">搜尋</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">關於</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">Atom</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/02/10/2015021001/">
                            自定义Android视图(02/04)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-02-10T10:29:00+09:00">
	
		    2月 10, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Custom_Drawing_自定义绘图">Custom Drawing 自定义绘图</h1><p>自定义视图中最重要的部分是其外观。自定义绘图的复杂性会根据你的APP而定。这节将会覆盖最常用的操作。</p>
<h2 id="Override_onDraw()_重载onDraw()">Override onDraw()  重载onDraw()</h2><p>绘制自定义视图最重要的部分就是重载<code>onDraw()</code>方法。<code>onDraw()</code>的参数是一个view可用来绘制自己的Canvas对象。</p>
<p>Canvas类定义了方法来绘制文字、线条、位图和其余很多图元（graphics primitives 基本图形）。<br>可以在onDraw()中使用这些方法来绘制自己的UI。</p>
<p>在调用任何绘制方法前，应该创建Paint对象。下节将详细介绍Paint.</p>
<h2 id="Create_Drawing_Objects_创建绘制对象">Create Drawing Objects 创建绘制对象</h2><p><code>android.graphics</code>框架将绘图分为两部分：</p>
<ul>
<li>画什么，用Canvas控制</li>
<li>怎么画，用Paint控制</li>
</ul>
<p>例如，Canvas提供了方法绘制直线，同时Paint提供定义直线颜色的方法。Canvas有方法绘制矩形，<br>Paint定义是否对其填充颜色。简单来说，Canvas定义你可以绘制的形状，Paint定义绘制图形的颜色、样式、字体。</p>
<p>在你绘制任何东西之前，你需要创建一个或多个Paint对象。PieChart例子通过init()来实现，通过构造函数来调用。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
   mTextPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);
   mTextPaint.setColor(mTextColor);
   <span class="keyword">if</span> (mTextHeight == <span class="number">0</span>) {
       mTextHeight = mTextPaint.getTextSize();
   } <span class="keyword">else</span> {
       mTextPaint.setTextSize(mTextHeight);
   }

   mPiePaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);
   mPiePaint.setStyle(Paint.Style.FILL);
   mPiePaint.setTextSize(mTextHeight);

   mShadowPaint = <span class="keyword">new</span> Paint(<span class="number">0</span>);
   mShadowPaint.setColor(<span class="number">0xff101010</span>);
   mShadowPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">8</span>, BlurMaskFilter.Blur.NORMAL));

   ...
</code></pre><p>提前创建对象是一个很重要的优化手段。View会被频繁的重绘，很多绘制对象需要昂贵的初始化。<br>在<code>onDraw()</code>中创建绘制对象将会降低性能，使UI出现卡顿。</p>
<h2 id="Handle_Layout_Events_处理布局事件">Handle Layout Events 处理布局事件</h2><p>为了妥善的绘制自定义视图，你需要知道它的尺寸。复杂的自定义视图通常会根据它在屏幕上区域的大小和尺寸进行多次布局计算。永远不要假设你的视图在屏幕上的大小。即使只有一个app使用你的view，该app需要处理不同屏幕尺寸，多个屏幕密度，水平、垂直模式下的不同高宽比。</p>
<p>虽然view有很多方法处理尺寸问题，但是它们中的绝大多数不需要被重载。如果你的视图不需要特别控制其大小，就只需要重载一个方法：<code>onSizeChanged()</code></p>
<p><code>onSizeChanged()</code>在你的视图第一次分配尺寸的时候被调用，之后任何原因引起视图尺寸改变都会调用它。在<code>onSizeChanged()</code>中计算位置、维度、和其他与视图相关的值，避免每次绘制的时候重复计算。<br>在PieChart例子中，PieChart视图在<code>onSizeChanged()</code>中计算边框矩形、相对位置、文本标签和其他视觉元素</p>
<p>当你的视图分配了一个大小，布局管理假设该尺寸包含此视图的所有padding。<br>当你计算视图尺寸的时候须处理padding值。<code>PieChart.onSizeChanged()</code>的例子：</p>
<pre><code><span class="comment">// 计算 padding</span>
<span class="keyword">float</span> xpad = (<span class="keyword">float</span>)(getPaddingLeft() + getPaddingRight());
<span class="keyword">float</span> ypad = (<span class="keyword">float</span>)(getPaddingTop() + getPaddingBottom());

<span class="comment">// 计算 label</span>
<span class="keyword">if</span> (mShowText) xpad += mTextWidth;

<span class="keyword">float</span> ww = (<span class="keyword">float</span>)w - xpad;
<span class="keyword">float</span> hh = (<span class="keyword">float</span>)h - ypad;

<span class="comment">// 计算pie能有多大</span>
<span class="keyword">float</span> diameter = Math.<span class="built_in">min</span>(ww, hh);
</code></pre><p>如果你需要更好的控制视图的布局参数，那就实现(implement)<code>onMeasure()</code>方法。该方法的参数是<br><code>View.MeasureSpec</code>，该值会告诉你视图的父节点希望你的视图尺寸是多少，还有这个尺寸是硬性规定的最大值，还是只是一个建议值。为了优化，这些值被加密(pack)存储为整数，使用静态<code>View.MeasureSpec</code>方法解密(unpack)每个整数中的信息。</p>
<p>PieChart 实现<code>onMeasure()</code>，试图创建它的区域足够大来让它的标签尽可能的大</p>
<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
   <span class="comment">// Try for a width based on our minimum</span>
   <span class="comment">// 基于最小值尝试得到宽度</span>
   <span class="keyword">int</span> minw = getPaddingLeft() + getPaddingRight() + getSuggestedMinimumWidth();
   <span class="keyword">int</span> w = resolveSizeAndState(minw, widthMeasureSpec, <span class="number">1</span>);

   <span class="comment">// Whatever the width ends up being, ask for a height that would let the pie</span>
   <span class="comment">// get as big as it can</span>
   <span class="comment">// 无论最终宽度多少，设置高度让pie尽可能的大</span>
   <span class="keyword">int</span> minh = MeasureSpec.getSize(w) - (<span class="keyword">int</span>)mTextWidth + getPaddingBottom() + getPaddingTop();
   <span class="keyword">int</span> h = resolveSizeAndState(MeasureSpec.getSize(w) - (<span class="keyword">int</span>)mTextWidth, heightMeasureSpec, <span class="number">0</span>);

   setMeasuredDimension(w, h);
}
</code></pre><p>代码中有三点需要注意：</p>
<ul>
<li>计算时考虑到了视图的padding。就像之前提到过的，这是视图的责任。</li>
<li>辅助方法<code>resolveSizeAndState()</code>用来创建最终的宽度、高度值。该辅助方法返回一个合适的<br><code>View.MeasureSpec</code>值，通过比较视图希望的大小和传入<code>onMeasure()</code>的详细说明（spec）</li>
<li><code>onMeasure()</code>没有返回值，相反，其通过调用<code>setMeasuredDimension()</code>提交计算结果。调用该方法是强制性的。如果你忽略这个调用，视图类将会抛出一个运行时错误</li>
</ul>
<h2 id="Draw!_绘制">Draw! 绘制</h2><p>一旦你创建对象、测量大小的代码完成了，你就可以实现<code>onDraw()</code>.  每个视图实现的<code>onDraw()</code>都不同，但是有一些绝大多数视图通用的操作：</p>
<ul>
<li>绘制文字用<code>drawText()</code>. 用<code>setTypeface()</code>指明字形，<code>setColor()</code>设置字体颜色。</li>
<li>用<code>drawRect(),drawOval(),drawArc()</code>绘制基础图形。<code>setStyle()</code>设置形状是否被填充、是否有外部轮廓</li>
<li>用Path类创建更复杂的图形。对Path对象定义添加直线、曲线，然后用<code>drawPath()</code>绘制图形。<br>和基础图形一样，可以对用<code>setStyle()</code>对path设置轮廓、填充。</li>
<li>用LinearGradient对象定义渐变填充。调用<code>setShader()</code>将定义的LinearGradient渐变填充至图形。</li>
<li>用<code>drawBitmap()</code>绘制位图</li>
</ul>
<p>例如PieChart中的代码；</p>
<pre><code>protected void onDraw(Canvas <span class="keyword">canvas</span>) {
   super.onDraw(<span class="keyword">canvas</span>);

   <span class="comment">// Draw the shadow</span>
   <span class="comment">// 绘制阴影</span>
   <span class="keyword">canvas</span>.drawOval(
           mShadowBounds,
           mShadowPaint
   );

   <span class="comment">// Draw the label text</span>
   <span class="comment">// 绘制标签文本</span>
   <span class="keyword">canvas</span>.drawText(mData.get(mCurrentItem).mLabel, mTextX, mTextY, mTextPaint);

   <span class="comment">// Draw the pie slices</span>
   <span class="comment">// 绘制pie切块</span>
   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mData.<span class="keyword">size</span>(); ++i) {
       Item it = mData.get(i);
       mPiePaint.setShader(it.mShader);
       <span class="keyword">canvas</span>.drawArc(mBounds,
               <span class="number">360</span> - it.mEndAngle,
               it.mEndAngle - it.mStartAngle,
               true, mPiePaint);
   }

   <span class="comment">// Draw the pointer</span>
   <span class="comment">// 绘制点</span>
   <span class="keyword">canvas</span>.drawLine(mTextX, mPointerY, mPointerX, mPointerY, mTextPaint);
   <span class="keyword">canvas</span>.drawCircle(mPointerX, mPointerY, mPointerSize, mTextPaint);
}
</code></pre>
                    
                        
                    
                    
                        <p>
                            <a href="/2015/02/10/2015021001/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/02/02/2015020201/">
                            自定义Android视图(01/04)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-02-02T10:37:52+09:00">
	
		    2月 02, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <blockquote>
<p>在网上总是搜不到很全面的自定义视图教程，大多数都是抄来抄去，即使买的书中相关内容也不是很多。所以还不如直接自己翻译下官方文档 <a href="http://developer.android.com/training/custom-views/" target="_blank" rel="external">custom views</a>. 一共四篇文章，分步翻译，这是第一篇。</p>
</blockquote>
<h1 id="Creating_a_View_Class_创建一个view类">Creating a View Class  创建一个view类</h1><p>一个精心设计的自定义view像其他精心设计的类一样。它包含一系列特别的功能，拥有简单的用户界面，高效使用CPU和内存等等。为达到这些目的，应该做到：  </p>
<ul>
<li>符合Android标准</li>
<li>提供可以和Android XML通用的自定义属性</li>
<li>支持多个Android平台</li>
</ul>
<p>Android 框架提供了一系列的基础类和XML标签来帮助你达到这些目标。</p>
<h2 id="Subclass_a_View_子类视图">Subclass a View 子类视图</h2><p>所有Android框架中的视图都拓展来自View类。 自定义的视图也可以直接拓展View，或者为了节省时间，拓展一个已经存在的子类，例如Button.</p>
<p>为了让ADT可以和你的view交互，至少要提供一个参数为Context和AttributeSet对象的构造器。该构造器允许布局编辑器创建、编辑自定义view的实例。 </p>
<h2 id="Define_Custom_Attributes_自定义属性">Define Custom Attributes 自定义属性</h2><p>为了在界面中添加一个原生的View，可以在XML元素中声明它，然后通过元素属性控制它的外观和行为。好的自定义view可以允许通过XML增加、改变样式。必须做到如下要求才能在自定义view中实现这些效果:  </p>
<ul>
<li>在&lt;declare-styleable&gt;资源元素中为你的view定义自定义属性 </li>
<li>在XML布局中指明属性的值 </li>
<li>在运行时取回属性数据 </li>
<li>将取回的数据应用在view中  </li>
</ul>
<p>这节将定义、设置属性值，下节将取回、使用这些值。<br>在你的项目中添加<code>&lt;declare-styleable&gt;</code>来定义自定义属性。通常这些自定义的放在<code>res/values/attrs.xml</code>文件中。例如：</p>
<pre><code><span class="tag">&lt;<span class="title">resources</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"PieChart"</span>&gt;</span> 
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"showText"</span> <span class="attribute">format</span>=<span class="value">"boolean"</span> /&gt;</span> 
        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"labelPosition"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span> 
            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span> 
            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span> 
        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span> 
    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
</code></pre><p>这段代码声明了两个自定义属性，<code>showText、labelPosition</code>，属于一个可变样式的实体<code>PieChart</code>.<br>可变样式实体的名字通常情况下和自定义view的类名相同。虽然没有严格的要求应该遵循这样的习惯，<br>但是很多流行的代码编辑器依赖这种命名习惯来提供语句结束（statement completion 状态补全？）。 </p>
<p>一旦定义了自定义属性，就能在布局XML文件中像原生属性一样使用它们。唯一的不用<br>在于，你的自定义属性属于不同的命名空间。它们属于<code>http://schemas.android.com/apk/res/[your package name]</code>而非<code>http://schemas.android.com/apk/res/android</code>.<br>举例如何在<code>PieChart</code>中使用为其定义的属性： </p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> 
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span> 
              <span class="attribute">xmlns:custom</span>=<span class="value">"http://schemas.android.com/apk/res/com.example.customviews"</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">com.example.customviews.charting.PieChart</span> 
        <span class="attribute">custom:showText</span>=<span class="value">"true"</span> 
        <span class="attribute">custom:labelPosition</span>=<span class="value">"left"</span> /&gt;</span> 
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span> 
</code></pre><p>为了避免重复的输入很长的命名URI，上面的例子用了xmlns缩写。这个缩写指明custom是<code>http://schemas.android.com/apk/res/com.example.customviews</code>的别名。<br>你可以为命名空间选择任意的别名。<br>（me:别名是在声明属性时候用的，也就是&lt;&gt;的内部，而不是&lt;&gt;的第一行）<br>注意在布局文件中添加自定义视图的XML tag(&lt;&gt;元素的第一行)的名字。它是自定义view的全路径名。<br>如果你的view类是内部类，就必须用它外部类来补全名字。例如，<code>PieCart</code>类有个内部<br>类<code>PieView</code>. 为了对这个类使用自定义属性，tag就必须使用<code>com.example.customviews.charting.PieChart$PieView</code></p>
<h2 id="Apply_Custom_Attributes_使用自定义属性">Apply Custom Attributes 使用自定义属性</h2><p>当在XML布局中创建view的时候，所有的XML tag都通过资源bundle被读取出来作为<code>AttributeSet</code>参数传递给view的构造函数。虽然有可能直接通过<code>AttributeSet</code>读取值，但是这么做会有以下缺点：</p>
<ul>
<li>属性值中的资源引用是未解析（解码？resolved）的 </li>
<li>样式未被应用 </li>
</ul>
<p>相反的，传递AttributeSet给<code>obtainStyledAttributes()</code>. 这个方法回传一个<code>TypeArray</code>数组，其中的值都已经被dereferenced（间接引用）、styled（样式化）。<br>Android的资源编译器为能轻松调用<code>obtainStyledAttributes()</code>做了大量工作。每个在res目录中的<code>&lt;declare-styleable&gt;</code>资源，生成R.java定义包含属性ids和常量集合（定义在数组中每个属性的索引）的数组。<br>使用预定义常量来通过<code>TypedArray</code>读取属性。举例<code>PieChart</code>类如何读取属性：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">PieChart</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{ 
    super(context, attrs); 
    TypedArray a = context.getTheme().obtainStyledAttributes( 
                                        attrs, 
                                        R.styleable.PieChart, 
                                        <span class="number">0</span>, <span class="number">0</span>);     

    <span class="keyword">try</span> { 
        mShowText = a.getBoolean(R.styleable.PieChart_showText, <span class="literal">false</span>); 
        mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, <span class="number">0</span>); 
    } finally { 
        a.recycle(); 
    } 
} 
</code></pre><p>注意TypedArray对象是一个共享资源，必须在使用后recycled.</p>
<h2 id="Add_Properties_and_Events_添加属性和事件">Add Properties and Events 添加属性和事件</h2><p>属性是控制view行为和外观强有力的工具，但是他们只能在view初始化的时候读取。为了提供动态行为，为每一个自定义属性(attribute)公布property getter和setter。举例PieChart如何暴漏(explode)出一个名为showText的property:</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isShowText</span><span class="params">()</span> </span>{ 
    <span class="keyword">return</span> mShowText; 
} 

<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setShowText</span><span class="params">(<span class="keyword">boolean</span> showText)</span> </span>{ 
    mShowText = showText; 
    invalidate(); 
    requestLayout(); 
} 
</code></pre><p>注意<code>setShowText</code>调用了<code>invalidate()</code>和<code>requestLayout()</code>。这些函数对于确保view的可靠表现非常重要。必须在修改view的任何property之后使其无效（invalidate），因为这可能引起外观改变，所以系统就会知道它需要被重绘。比如，如果一个可能影响view的大小或形状property被改变，你就必须请求一个新的布局。忘记调用这些函数可能产生难以调试的问题。 </p>
<p>为和重要的事件沟通，自定义view同样应当支持事件监听。例如PieChart暴漏了一个名为<code>OnCurrentItemChanged</code>自定义事件，来通知监听器用户旋转了饼状图，聚焦在一个新的切块上。 </p>
<p>很容易遗忘公布property和监听器，特别是只有你使用这个自定义视图时。花些时间规划自定义view的接口，就能减少将来维护的成本。<br>一个好的规范是总是公布所有会影响view外观、行为的property。 </p>
<h2 id="Design_For_Accessibility_为易用性设计">Design For Accessibility 为易用性设计</h2><p>你的自定义view应当支持尽可能多的用户。包括那些因为身体残疾无法看到或使用触摸屏的人。<br>为了支持残疾人，你应该遵循下面的规则： </p>
<ul>
<li>用<code>android:contentDescription</code>来标注你的输入框 </li>
<li>适当的时候调用<code>sendAccessibilityEvent()</code>发送无障碍(accessibility)事件 </li>
<li>持替换控制器，例如D-pad 和 trackball </li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/02/02/2015020201/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/01/30/2015013001/">
                            Git的分支管理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-01-30T20:15:14+09:00">
	
		    1月 30, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>一直很好奇git的分支来回切换的时候会有什么用处，是的真正的修改源文件，还是只记录在.git里面，等到需要的时候再做处理</p>
<p>实验如下：</p>
<h1 id="第一部分：创建不同branch">第一部分：创建不同branch</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir branchgit    // 新建文件夹</span><br><span class="line"><span class="built_in">cd</span> branckgit  </span><br><span class="line">git init           // 初始化git</span><br><span class="line">vim index.html     // 新建文件index.html</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>修改index.html文件，回到shell中保存修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .          // 已改变的文件和从未添加过的文件是一个级别，都要add一下</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></p>
<p>此时完成master分支的修改，创建一个新的branch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch editor</span><br><span class="line">``` </span><br><span class="line">此时还不会自动切换过去，要自己执行下面的命令</span><br><span class="line">```bash</span><br><span class="line">git checkout editor</span><br></pre></td></tr></table></figure></p>
<p>这时就能切过去，shell提示符[]中亮蓝色的就是当前分支</p>
<p>此时修改文件，添加部分语句后，在editor分支中<code>git add . ; git commit</code></p>
<p>此时准备工作完成，来回切换branch就是下面的gif所示</p>
<p>master -&gt; editor 点击index.html，看到index.html添加了一些代码</p>
<p>editor -&gt; master 点击index.html，看到index.html减少了一些代码</p>
<p><img src="http://i.imgur.com/7h0QBjH.gif" alt="git branch"></p>
<h1 id="第二部分：branch之间的合并">第二部分：branch之间的合并</h1><p>我们在editor分支上添加完了新功能，现在又想回到master添加功能，这时变成了在两个分支都向前推进了代码，此时进行合并</p>
<pre><code>git merge editor
</code></pre>
果断报错，提示我们有冲突 CONFLICT，此时就需要我们人工进行合并了
<pre><code>&lt;&lt;&lt;&lt;  HEAD
======
&gt;&gt;&gt;&gt;  editor
</code></pre>

<p>这三行中间分隔了两个代码块，就是git无法自己确定那个在前的问题，因为我们在两个分支对同一个文件同一行都向前推进了<br>所以调整一下这两个代码块，同时删除三行提示<br>保存回到git中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit <span class="operator">-a</span></span><br></pre></td></tr></table></figure></p>
<p>OK，一切搞定<br>此时我们就把再editor中创建的代码合并到了master中，再切回editor看下，里面的代码没有改变</p>
<p><img src="http://i.imgur.com/eCci1zD.gif" alt="git branch merge"></p>
<h1 id="第三部分：图形化查看git的已经走过的路线">第三部分：图形化查看git的已经走过的路线</h1><p>命令行输入<code>gitk</code>可以直接看到图形化的显示，注意在不同的branch上看到的结果是不同的</p>
<p>PS：<br><code>git commit -a = git add . ; git commit</code><br>但是简化的命令无法加入新建的文件，所以如果要修改，还得老实的输入两条命令</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/01/30/2015013001/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/01/29/2015012901/">
                            尝试zsh
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-01-29T10:00:56+09:00">
	
		    1月 29, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>测试平台  </p>
<blockquote>
<p>CentOS 6.5 64bit  </p>
</blockquote>
<p>oh-my-zsh的<a href="https://github.com/robbyrussell/oh-my-zsh" title="github  oh-my-zsh" target="_blank" rel="external">项目地址</a><br>在bash中直接执行下面语句，即可从git中下载到oh-my-zsh代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>因为我之前没有使用过zsh，所以也不需要备份自己的<code>.zshrc</code>文件，可以放心的cp</p>
<p>正因为我之前完全没有使用过zsh，安装centos的时候也没有安装zsh，所以如果此时直接执行zsh将会报错<br>如果执行<code>source .zshrc</code>会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash /root/.oh-my-zsh/oh-my-zsh.sh: line <span class="number">19</span>: syntax error near unexpected token `(<span class="string">'</span><br><span class="line">bash: /root/.oh-my-zsh/oh-my-zsh.sh: line 19: `for config_file ($ZSH/lib/*.zsh); do'</span></span><br></pre></td></tr></table></figure></p>
<p>找到一个官方的<a href="https://github.com/robbyrussell/oh-my-zsh/issues/2527" target="_blank" rel="external">issue</a>比较有用，其中提到“需要把默认终端改成zsh”，也就是先切换到zsh，再执行<code>source .zshrc</code>才能生效</p>
<p>想了半天，给自己蠢哭了….oh-my-zsh是没有自带安装zsh的，只是封装了一些配置….<br>看看官方解释：</p>
<blockquote>
<p>oh-my-zsh is an open source, community-driven framework for managing your Zsh configuration.<br>oh-my-zsh 是一个开源的、社区驱动的框架，用来管理你的zsh配置</p>
</blockquote>
<p>所以，先安装一下zsh….</p>
<p><pre><code>yum install zsh</code></pre><br>之后就可以顺利执行，在cp完.zshrc之后</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsh  // 先在bash中进入zsh</span><br><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure>
<p>这就可以使用oh-my-zsh了~</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/01/29/2015012901/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2015/01/15/20150115/">
                            emacs配置自动加载autopair
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2015-01-15T10:28:38+09:00">
	
		    1月 15, 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>每次启动emacs的时候，不管进入哪个mode输入”(“都不能自动出现”)”并把光标放到中间<br>很麻烦，所以找到插件autopair，但是安装好后还是不会自动启动<br>每次都要M-x autopair 才行，依旧不方便<br>所以为了让它自启动，折腾了很久，终于搞定，记录一下~</p>
<blockquote>
<p>平台:<br>Windows 8.1 X64<br>emacs 24</p>
</blockquote>
<ol>
<li><p>打开文件<code>C:\Users\jedi\AppData\Roaming\.emacs.d\init.el</code>根据已经有的配置，找到合适位置输入<code>(require &#39;init-autopair)</code>，要避免添加到不生效的位置，因为配置文件中会判断平台</p>
</li>
<li><p>在下面的文件夹<code>C:\Users\jedi\AppData\Roaming\.emacs.d\lisp\</code>新建文件<code>init-autopair.el</code><br>输入内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(require &#39;autopair)&#10;(autopair-global-mode)&#10;(provide &#39;init-autopair)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>前两行为autopair.el中的文档注释内容，后一行自己添加，等于告诉其他地方，这个包就是init-autopair，否则会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Required feature &#39;init-autopair&#39; was not provided&#10;To ensure normal operation, you should investigate and remove the&#10;cause of the error in your initialization file. Start Emacs with&#10;the &#39;--debug-init&#39; option to view a complete error backtrace.</span><br></pre></td></tr></table></figure>
<ol>
<li>最后<code>c:\Users\jedi\AppData\Roaming\.emacs.d\site-lisp\</code><br>新建文件夹autopair，把autopair.el拷进去，之后每次启动emacs就能直接使用autopair</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2015/01/15/20150115/#post-footer" class="postShorten-excerpt_link link">
                                留言與分享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/archives/2015/page/2/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>上一頁</span>
            </a>
        </li>
        
        
        <li class="pagination-number">第 3 頁 共 3 頁</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2016 Taxus. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Taxus</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js" type="text/javascript"></script>
<!--SCRIPTS END-->



</html>
